# -*- coding: utf-8 -*-
"""epc06.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q7_8MQdn8ecRrPF4PNNVxGf7YuWRzxox
"""

pip install -U scikit-fuzzy

# Importando numpy
import numpy as np

# Importando pandas 
import pandas as pd

# Importando skfuzzy
import skfuzzy as fuzz

# Importando `pyplot` de `matplotlib`
from matplotlib import pyplot as plt

def generate_empty_matrix(rows, cols):
  matrix = [];
  for i in range(rows):
    line = [];
    for j in range(cols):
      line.append(0);
    matrix.append(line);
  return matrix;

def generate_empty_list(rows):
  matrix = [];
  for i in range(rows):
    matrix.append(0);
  return matrix;

def score_rules(rules):
  score = []
  for i in range(len(rules)):
    score.append(rules[i][0]['interp_membership']*rules[i][1]['interp_membership']*rules[i][2]['interp_membership']*rules[i][3]['interp_membership'])
  return score

def score_rules_degree(rules_degree):
  score_rules_with_degree = []
  for i in range(len(rules_degree)):
    score_rules_with_degree.append(rules_degree[i][0]['interp_membership']*rules_degree[i][1]['interp_membership']*rules_degree[i][2]['interp_membership']*rules_degree[i][3]['interp_membership']*rules_degree[i][5]['degree'])
  return score_rules_with_degree

def delete_conflict(rules, score):
  min_membership = set()
  rules_without_conflict = []

  for i in range(len(rules) - 1):
    for j in range(i + 1, len(rules)):
      if (rules[i][0]['region'] == rules[j][0]['region']) and (rules[i][1]['region'] == rules[j][1]['region']) and (rules[i][2]['region'] == rules[j][2]['region']) and (rules[i][3]['region'] == rules[j][3]['region']) and (rules[i][4]['classe'] != rules[j][4]['classe']):
        if (score[i] > score[j]):
          min_membership.add(j)
        else:
          min_membership.add(i)

  for i in range(len(rules)):
    if not (i in min_membership):
      rules_without_conflict.append(rules[i])

  return rules_without_conflict

def filter_rules(rules_):
  rules = rules_.copy()
  class1 = set()
  class2 = set()
  class3 = set()  
  
  for i in range(len(rules)):
    if rules[i][4]['classe'] == 1:
      class1.add(f"{rules[i][0]['region']}{rules[i][1]['region']}{rules[i][2]['region']}{rules[i][3]['region']}")
    elif rules[i][4]['classe'] == 2:
      class2.add(f"{rules[i][0]['region']}{rules[i][1]['region']}{rules[i][2]['region']}{rules[i][3]['region']}")
    elif rules[i][4]['classe'] == 3:
      class3.add(f"{rules[i][0]['region']}{rules[i][1]['region']}{rules[i][2]['region']}{rules[i][3]['region']}")
  
  rules_class1 = []
  rules_class2 = []
  rules_class3 = []
  final_rules = []

  for el in class1:
    text_rule = ''
    rule = []
    for i in range(len(el)):
      if i == 0:
        if el[i] == '1':
          text_rule = "Se SepalLength é small & "
          rule.append({'region': 1})
        elif el[i] == '2':
          text_rule = f"Se SepalLength é medium & "
          rule.append({'region': 2})
        elif el[i] == '3':
          text_rule = "Se SepalLength é big & "
          rule.append({'region': 3})
      elif i == 1:
        if el[i] == '1':
          text_rule += "SepalWidth é small & "
          rule.append({'region': 1})
        elif el[i] == '2':
          text_rule += "SepalWidth é medium & "
          rule.append({'region': 2})
        elif el[i] == '3':
          text_rule += "SepalWidth é big & "
          rule.append({'region': 3})
      elif i == 2:
        if el[i] == '1':
          text_rule += "PetalLength é small & "
          rule.append({'region': 1})
        elif el[i] == '2':
          text_rule += "PetalLength é medium & "
          rule.append({'region': 2})
        elif el[i] == '3':
          text_rule += "PetalLength é big & "
          rule.append({'region': 3})
      elif i == 3:
        if el[i] == '1':
          text_rule += "PetalWidth é small, "
          rule.append({'region': 1})
        elif el[i] == '2':
          text_rule += "PetalWidth é medium, "
          rule.append({'region': 2})
        elif el[i] == '3':
          text_rule += "PetalWidth é big, "
          rule.append({'region': 3})
    rule.append({'classe': 1})
    rules_class1.append(rule)
    text_rule += "Então a planta é Iris-setosa"
    final_rules.append(text_rule)

  for el in class2:
    text_rule = ''
    rule = []
    for i in range(len(el)):
      if i == 0:
        if el[i] == '1':
          text_rule = "Se SepalLength é small & "
          rule.append({'region': 1})
        elif el[i] == '2':
          text_rule = f"Se SepalLength é medium & "
          rule.append({'region': 2})
        elif el[i] == '3':
          text_rule = "Se SepalLength é big & "
          rule.append({'region': 3})
      elif i == 1:
        if el[i] == '1':
          text_rule += "SepalWidth é small & "
          rule.append({'region': 1})
        elif el[i] == '2':
          text_rule += "SepalWidth é medium & "
          rule.append({'region': 2})
        elif el[i] == '3':
          text_rule += "SepalWidth é big & "
          rule.append({'region': 3})
      elif i == 2:
        if el[i] == '1':
          text_rule += "PetalLength é small & "
          rule.append({'region': 1})
        elif el[i] == '2':
          text_rule += "PetalLength é medium & "
          rule.append({'region': 2})
        elif el[i] == '3':
          text_rule += "PetalLength é big & "
          rule.append({'region': 3})
      elif i == 3:
        if el[i] == '1':
          text_rule += "PetalWidth é small, "
          rule.append({'region': 1})
        elif el[i] == '2':
          text_rule += "PetalWidth é medium, "
          rule.append({'region': 2})
        elif el[i] == '3':
          text_rule += "PetalWidth é big, "
          rule.append({'region': 3})
    rule.append({'classe': 2})
    rules_class2.append(rule)
    text_rule += "Então a planta é Iris-versicolor"
    final_rules.append(text_rule)

  for el in class3:
    text_rule = ''
    rule = []
    for i in range(len(el)):
      if i == 0:
        if el[i] == '1':
          text_rule = "Se SepalLength é small & "
          rule.append({'region': 1})
        elif el[i] == '2':
          text_rule = f"Se SepalLength é medium & "
          rule.append({'region': 2})
        elif el[i] == '3':
          text_rule = "Se SepalLength é big & "
          rule.append({'region': 3})
      elif i == 1:
        if el[i] == '1':
          text_rule += "SepalWidth é small & "
          rule.append({'region': 1})
        elif el[i] == '2':
          text_rule += "SepalWidth é medium & "
          rule.append({'region': 2})
        elif el[i] == '3':
          text_rule += "SepalWidth é big & "
          rule.append({'region': 3})
      elif i == 2:
        if el[i] == '1':
          text_rule += "PetalLength é small & "
          rule.append({'region': 1})
        elif el[i] == '2':
          text_rule += "PetalLength é medium & "
          rule.append({'region': 2})
        elif el[i] == '3':
          text_rule += "PetalLength é big & "
          rule.append({'region': 3})
      elif i == 3:
        if el[i] == '1':
          text_rule += "PetalWidth é small, "
          rule.append({'region': 1})
        elif el[i] == '2':
          text_rule += "PetalWidth é medium, "
          rule.append({'region': 2})
        elif el[i] == '3':
          text_rule += "PetalWidth é big, "
          rule.append({'region': 3})
    rule.append({'classe': 3})
    rules_class3.append(rule)
    text_rule += "Então a planta é Iris-virginica"
    final_rules.append(text_rule)

  return rules_class1, rules_class2, rules_class3, final_rules

def generate_regions(x_train):
  min_sl = min(x_train[:,0])
  max_sl = max(x_train[:,0])
  sepal_length = np.linspace(min_sl, max_sl, 500)

  sl_sm = fuzz.trimf(sepal_length, [min_sl, min_sl, min_sl + (max_sl-min_sl)/2])
  sl_me = fuzz.trimf(sepal_length, [min_sl + (max_sl-min_sl)/4, min_sl + (max_sl-min_sl)/2, min_sl + 3*(max_sl-min_sl)/4])
  sl_bi = fuzz.trimf(sepal_length, [min_sl + (max_sl-min_sl)/2, max_sl, max_sl])

  min_sw = min(x_train[:,1])
  max_sw = max(x_train[:,1])
  sepal_width = np.linspace(min_sw, max_sw, 500)

  sw_sm = fuzz.trimf(sepal_width, [min_sw, min_sw, min_sw + (max_sw-min_sw)/2])
  sw_me = fuzz.trimf(sepal_width, [min_sw + (max_sw-min_sw)/4, min_sw + (max_sw-min_sw)/2, min_sw + 3*(max_sw-min_sw)/4])
  sw_bi = fuzz.trimf(sepal_width, [min_sw + (max_sw-min_sw)/2, max_sw, max_sw])

  min_pl = min(x_train[:,2])
  max_pl = max(x_train[:,2])
  petal_length = np.linspace(min_pl, max_pl, 500)

  pl_sm = fuzz.trimf(petal_length, [min_pl, min_pl, min_pl + (max_pl-min_pl)/2])
  pl_me = fuzz.trimf(petal_length, [min_pl + (max_pl-min_pl)/4, min_pl + (max_pl-min_pl)/2, min_pl + 3*(max_pl-min_pl)/4])
  pl_bi = fuzz.trimf(petal_length, [min_pl + (max_pl-min_pl)/2, max_pl, max_pl])

  min_pw = min(x_train[:,3])
  max_pw = max(x_train[:,3])
  petal_width = np.linspace(min_pw, max_pw, 500)

  pw_sm = fuzz.trimf(petal_width, [min_pw, min_pw, min_pw + (max_pw-min_pw)/2])
  pw_me = fuzz.trimf(petal_width, [min_pw + (max_pw-min_pw)/4, min_pw + (max_pw-min_pw)/2, min_pw + 3*(max_pw-min_pw)/4])
  pw_bi = fuzz.trimf(petal_width, [min_pw + (max_pw-min_pw)/2, max_pw, max_pw])
  
  return sepal_length, sl_sm, sl_me, sl_bi, sepal_width, sw_sm, sw_me, sw_bi, petal_length, pl_sm, pl_me, pl_bi, petal_width, pw_sm, pw_me, pw_bi

def pertinence(input_sample, sepal_length, sl_sm, sl_me, sl_bi, sepal_width, sw_sm, sw_me, sw_bi, petal_length, pl_sm, pl_me, pl_bi, petal_width, pw_sm, pw_me, pw_bi):
  sl_small = fuzz.interp_membership(sepal_length, sl_sm, input_sample[0])
  sl_medium = fuzz.interp_membership(sepal_length, sl_me, input_sample[0])
  sl_big = fuzz.interp_membership(sepal_length, sl_bi, input_sample[0])
  
  membership_sl = {'1': sl_small, '2': sl_medium, '3': sl_big}
  
  sw_small = fuzz.interp_membership(sepal_width, sw_sm, input_sample[1])
  sw_medium = fuzz.interp_membership(sepal_width, sw_me, input_sample[1])
  sw_big = fuzz.interp_membership(sepal_width, sw_bi, input_sample[1])
  
  membership_sw = {'1': sw_small, '2': sw_medium, '3': sw_big}
  
  pl_small = fuzz.interp_membership(petal_length, pl_sm, input_sample[2])
  pl_medium = fuzz.interp_membership(petal_length, pl_me, input_sample[2])
  pl_big = fuzz.interp_membership(petal_length, pl_bi, input_sample[2])
  
  membership_pl = {'1': pl_small, '2': pl_medium, '3': pl_big}
  
  pw_small = fuzz.interp_membership(petal_width, sl_sm, input_sample[3])
  pw_medium = fuzz.interp_membership(petal_width, sl_me, input_sample[3])
  pw_big = fuzz.interp_membership(petal_width, sl_bi, input_sample[3])

  membership_pw = {'1': pw_small, '2': pw_medium, '3': pw_big}

  return membership_sl, membership_sw, membership_pl, membership_pw

def degree(betas):
  b = (sum(betas) - max(betas))/(len(betas)-1)
  return abs(max(betas) - b)/sum(betas)

def hisao_ishibuchi(input_train_data, output_train_data, sepal_length, sl_sm, sl_me, sl_bi, sepal_width, sw_sm, sw_me, sw_bi, petal_length, pl_sm, pl_me, pl_bi, petal_width, pw_sm, pw_me, pw_bi, rules):
  rules_with_degree = rules.copy()
  for r in range(len(rules_with_degree)):
    beta_g1 = 0
    beta_g2 = 0
    beta_g3 = 0
    betas = generate_empty_list(3)
    
    for sample in range(input_train_data.shape[0]):
      membership_sl, membership_sw, membership_pl, membership_pw = pertinence(input_train_data[sample], sepal_length, sl_sm, sl_me, sl_bi, sepal_width, sw_sm, sw_me, sw_bi, petal_length, pl_sm, pl_me, pl_bi, petal_width, pw_sm, pw_me, pw_bi)
      
      if rules_with_degree[r][4]['classe'] == 1:
        beta_g1 += membership_sl[f"{rules_with_degree[r][0]['region']}"] * membership_sw[f"{rules_with_degree[r][1]['region']}"] * membership_pl[f"{rules_with_degree[r][2]['region']}"] * membership_pw[f"{rules_with_degree[r][3]['region']}"]
      elif rules_with_degree[r][4]['classe'] == 2:
        beta_g2 += membership_sl[f"{rules_with_degree[r][0]['region']}"] * membership_sw[f"{rules_with_degree[r][1]['region']}"] * membership_pl[f"{rules_with_degree[r][2]['region']}"] * membership_pw[f"{rules_with_degree[r][3]['region']}"]
      elif rules_with_degree[r][4]['classe'] == 3:
        beta_g3 += membership_sl[f"{rules_with_degree[r][0]['region']}"] * membership_sw[f"{rules_with_degree[r][1]['region']}"] * membership_pl[f"{rules_with_degree[r][2]['region']}"] * membership_pw[f"{rules_with_degree[r][3]['region']}"]
    
    betas[0] = beta_g1
    betas[1] = beta_g2
    betas[2] = beta_g3
    
    rules_with_degree[r].append({'degree': degree(betas)})
  return rules_with_degree

def wang_mendel(input_train_data, output_train_data, sepal_length, sl_sm, sl_me, sl_bi, sepal_width, sw_sm, sw_me, sw_bi, petal_length, pl_sm, pl_me, pl_bi, petal_width, pw_sm, pw_me, pw_bi):
  rules = generate_empty_matrix(input_train_data.shape[0], 0)

  for sample in range(input_train_data.shape[0]):
    sl_small = fuzz.interp_membership(sepal_length, sl_sm, input_train_data[sample][0])
    sl_medium = fuzz.interp_membership(sepal_length, sl_me, input_train_data[sample][0])
    sl_big = fuzz.interp_membership(sepal_length, sl_bi, input_train_data[sample][0])
    
    membership_sl = [sl_small, sl_medium, sl_big]
    
    sw_small = fuzz.interp_membership(sepal_width, sw_sm, input_train_data[sample][1])
    sw_medium = fuzz.interp_membership(sepal_width, sw_me, input_train_data[sample][1])
    sw_big = fuzz.interp_membership(sepal_width, sw_bi, input_train_data[sample][1])

    membership_sw = [sw_small, sw_medium, sw_big]
    
    pl_small = fuzz.interp_membership(petal_length, pl_sm, input_train_data[sample][2])
    pl_medium = fuzz.interp_membership(petal_length, pl_me, input_train_data[sample][2])
    pl_big = fuzz.interp_membership(petal_length, pl_bi, input_train_data[sample][2])
    
    membership_pl = [pl_small, pl_medium, pl_big]
    
    pw_small = fuzz.interp_membership(petal_width, sl_sm, input_train_data[sample][3])
    pw_medium = fuzz.interp_membership(petal_width, sl_me, input_train_data[sample][3])
    pw_big = fuzz.interp_membership(petal_width, sl_bi, input_train_data[sample][3])

    membership_pw = [pw_small, pw_medium, pw_big]

    for m in range(len(membership_sl)):
      if (membership_sl[m] == max(membership_sl)) and len(rules[sample]) == 0:
        rules[sample].append({'region': m + 1 , 'interp_membership': membership_sl[m]})
    
    for m in range(len(membership_sw)):
      if (membership_sw[m] == max(membership_sw)) and len(rules[sample]) == 1:
        rules[sample].append({'region': m + 1, 'interp_membership': membership_sw[m]})

    for m in range(len(membership_pl)):
      if (membership_pl[m] == max(membership_pl)) and len(rules[sample]) == 2:
        rules[sample].append({'region': m + 1, 'interp_membership': membership_pl[m]})
    
    for m in range(len(membership_pw)):
      if (membership_pw[m] == max(membership_pw)) and len(rules[sample]) == 3:
        rules[sample].append({'region': m + 1, 'interp_membership': membership_pw[m]})
    rules[sample].append({'classe': output_train_data[sample]})
    
  rules_with_degree = hisao_ishibuchi(x_train, y_train, sepal_length, sl_sm, sl_me, sl_bi, sepal_width, sw_sm, sw_me, sw_bi, petal_length, pl_sm, pl_me, pl_bi, petal_width, pw_sm, pw_me, pw_bi, rules)
    
  score = score_rules(rules)
  score_with_degree = score_rules_degree(rules_with_degree)
  
  rules_without_conflict = delete_conflict(rules, score)
  rules_class1, rules_class2, rules_class3, final_rules = filter_rules(rules_without_conflict)
  
  rules_with_degree_without_conflict = delete_conflict(rules_with_degree, score_with_degree)
  rules_with_degree_class1, rules_with_degree_class2, rules_with_degree_class3, final_rules_degree = filter_rules(rules_with_degree_without_conflict)

  return rules, rules_class1, rules_class2, rules_class3, final_rules, rules_with_degree, rules_with_degree_class1, rules_with_degree_class2, rules_with_degree_class3, final_rules_degree

def list_no_zero(list):
  aux = []
  for l in list:
    if l > 0:
      aux.append(l)
  return aux

def classify(x_test, y_test, sepal_length, sl_sm, sl_me, sl_bi, sepal_width, sw_sm, sw_me, sw_bi, petal_length, pl_sm, pl_me, pl_bi, petal_width, pw_sm, pw_me, pw_bi, rules1, rules2, rules3):
  classes_mrfc = generate_empty_list(y_test.shape[0])
  classes_mrfg = generate_empty_list(y_test.shape[0])

  rules_class1 = rules1.copy()
  rules_class2 = rules2.copy()
  rules_class3 = rules3.copy()
  
  t_norm1 = generate_empty_list(len(rules_class1))
  t_norm2 = generate_empty_list(len(rules_class2))
  t_norm3 = generate_empty_list(len(rules_class3))
  
  for sample in range(x_test.shape[0]):
    membership_sl, membership_sw, membership_pl, membership_pw = pertinence(x_test[sample], sepal_length, sl_sm, sl_me, sl_bi, sepal_width, sw_sm, sw_me, sw_bi, petal_length, pl_sm, pl_me, pl_bi, petal_width, pw_sm, pw_me, pw_bi)

    # Extraindo as mínimas pertinências da regra
    for i in range(len(rules_class1)):
      norm = []
      norm.append(membership_sl[f"{rules_class1[i][0]['region']}"])
      norm.append(membership_sw[f"{rules_class1[i][1]['region']}"])
      norm.append(membership_pl[f"{rules_class1[i][2]['region']}"])
      norm.append(membership_pw[f"{rules_class1[i][3]['region']}"])
      t_norm1[i] = min(norm)

    for i in range(len(rules_class2)):
      norm = []
      norm.append(membership_sl[f"{rules_class2[i][0]['region']}"])
      norm.append(membership_sw[f"{rules_class2[i][1]['region']}"])
      norm.append(membership_pl[f"{rules_class2[i][2]['region']}"])
      norm.append(membership_pw[f"{rules_class2[i][3]['region']}"])
      t_norm2[i] = min(norm)

    for i in range(len(rules_class3)):
      norm = []
      norm.append(membership_sl[f"{rules_class3[i][0]['region']}"])
      norm.append(membership_sw[f"{rules_class3[i][1]['region']}"])
      norm.append(membership_pl[f"{rules_class3[i][2]['region']}"])
      norm.append(membership_pw[f"{rules_class3[i][3]['region']}"])
      t_norm3[i] = min(norm)
   
    # Eliminando as pertinências de valor zeros das mínimas pertinências da regra
    n1 = list_no_zero(t_norm1)
    n2 = list_no_zero(t_norm2)
    n3 = list_no_zero(t_norm3)

    # Classficação utilizando MRFC
    if len(n1) > 0 and len(n2) > 0 and len(n3) > 0:
      if max(n1) > max(n2) and max(n1) > max(n3):
        classes_mrfc[sample] = 1
      if max(n2) > max(n1) and max(n2) > max(n3):
        classes_mrfc[sample] = 2
      if max(n3) > max(n1) and max(n3) > max(n2):
        classes_mrfc[sample] = 3
    elif len(n1) > 0 and len(n2) > 0:
      if max(n1) > max(n2):
        classes_mrfc[sample] = 1
      elif max(n1) < max(n2):
        classes_mrfc[sample] = 2
    elif len(n1) > 0 and len(n3) > 0:
      if max(n1) > max(n3):
        classes_mrfc[sample] = 1
      elif max(n1) < max(n3):
        classes_mrfc[sample] = 3
    elif len(n2) > 0 and len(n3) > 0:
      if max(n2) > max(n3):
        classes_mrfc[sample] = 2
      elif max(n2) < max(n3):
        classes_mrfc[sample] = 3
    elif len(n1) > 0:
      classes_mrfc[sample] = 1
    elif len(n2) > 0:
      classes_mrfc[sample] = 2
    elif len(n3) > 0:
      classes_mrfc[sample] = 3

    # Classficação utilizando MRFG
    if len(n1) > 0 and len(n2) > 0 and len(n3) > 0:
      if np.mean(n1) > np.mean(n2) and np.mean(n1) > np.mean(n3):
        classes_mrfg[sample] = 1
      if np.mean(n2) > np.mean(n1) and np.mean(n2) > np.mean(n3):
        classes_mrfg[sample] = 2
      if np.mean(n3) > np.mean(n1) and np.mean(n3) > np.mean(n2):
        classes_mrfg[sample] = 3
    elif len(n1) > 0 and len(n2) > 0:
      if np.mean(n1) > np.mean(n2):
        classes_mrfg[sample] = 1
      elif np.mean(n1) < np.mean(n2):
        classes_mrfg[sample] = 2
    elif len(n1) > 0 and len(n3) > 0:
      if np.mean(n1) > np.mean(n3):
        classes_mrfg[sample] = 1
      elif np.mean(n1) < np.mean(n3):
        classes_mrfg[sample] = 3
    elif len(n2) > 0 and len(n3) > 0:
      if np.mean(n2) > np.mean(n3):
        classes_mrfg[sample] = 2
      elif np.mean(n2) < np.mean(n3):
        classes_mrfg[sample] = 3
    elif len(n1) > 0:
      classes_mrfg[sample] = 1
    elif len(n2) > 0:
      classes_mrfg[sample] = 2
    elif len(n3) > 0:
      classes_mrfg[sample] = 3

  # Cálculo de acurácia da classificação utilizando MRFC      
  accuracy_mrfc = 0
  for c in range(y_test.shape[0]):
    if classes_mrfc[c] == y_test[c]:
      accuracy_mrfc = accuracy_mrfc + 1

  accuracy_mrfc = (accuracy_mrfc / y_test.shape[0]) * 100

  # Cálculo de acurácia da classificação utilizando MRFG
  accuracy_mrfg = 0
  for c in range(y_test.shape[0]):
    if classes_mrfg[c] == y_test[c]:
      accuracy_mrfg = accuracy_mrfg + 1

  accuracy_mrfg = (accuracy_mrfg / y_test.shape[0]) * 100

  return classes_mrfc, accuracy_mrfc, classes_mrfg, accuracy_mrfg

acc_mrfc = []
acc_mrfg = []
acc_mrfc_degree = []
acc_mrfg_degree = []

# Importando dados de treinamento e dados de teste para Iris plants dataset
for i in range(10):
  train_data = pd.read_csv('https://raw.githubusercontent.com/Joacy/pgcc015-inteligencia-computacional/master/epc/epc03/iris-plants/iris-10-'+ str(i + 1) +'tra.txt', sep=',')
  test_data = pd.read_csv('https://raw.githubusercontent.com/Joacy/pgcc015-inteligencia-computacional/master/epc/epc03/iris-plants/iris-10-'+ str(i + 1) +'tst.txt', sep=',')
  
  # Separando entradas e saídas para o treinamento
  x_train = np.array(train_data.iloc[:,0:4])
  y_train_text = train_data.iloc[:,4:5]
  out_train = np.array(y_train_text)

  # Convertendo o nome das plantas em números para o y_train
  y_train = []
  for j in range(y_train_text.size):
    if out_train[j] == ' Iris-setosa':
      y_train.append(1)
    elif out_train[j] == ' Iris-versicolor':
      y_train.append(2)
    elif out_train[j] == ' Iris-virginica':
      y_train.append(3)
  
  y_train = np.array(y_train)
  
  # Separando entradas e saídas para o teste
  x_test = np.array(test_data.iloc[:,0:4])
  y_test_text = np.array(test_data.iloc[:,4:5])
  out_test = np.array(y_test_text)
  
  # Convertendo o nome das plantas em números para o y_test
  y_test = []
  for j in range(y_test_text.size):
    if out_test[j] == ' Iris-setosa':
      y_test.append(1)
    elif out_test[j] == ' Iris-versicolor':
      y_test.append(2)
    elif out_test[j] == ' Iris-virginica':
      y_test.append(3)
  y_test = np.array(y_test)
  
  # Gerando universo e as regiões fuzzy para cada variável da amostra
  sepal_length, sl_sm, sl_me, sl_bi, sepal_width, sw_sm, sw_me, sw_bi, petal_length, pl_sm, pl_me, pl_bi, petal_width, pw_sm, pw_me, pw_bi = generate_regions(x_train)
  
  # # Visualizando universos
  # fig, (ax0, ax1, ax2, ax3) = plt.subplots(nrows=4, figsize=(8, 9))

  # ax0.plot(sepal_length, sl_sm, 'b', linewidth=1.5, label='Small')
  # ax0.plot(sepal_length, sl_me, 'g', linewidth=1.5, label='Medium')
  # ax0.plot(sepal_length, sl_bi, 'r', linewidth=1.5, label='Big')
  # ax0.set_title('Sepal Length')
  # ax0.legend()

  # ax1.plot(sepal_width, sw_sm, 'b', linewidth=1.5, label='Small')
  # ax1.plot(sepal_width, sw_me, 'g', linewidth=1.5, label='Medium')
  # ax1.plot(sepal_width, sw_bi, 'r', linewidth=1.5, label='Big')
  # ax1.set_title('Sepal Width')
  # ax1.legend()

  # ax2.plot(petal_length, pl_sm, 'b', linewidth=1.5, label='Small')
  # ax2.plot(petal_length, pl_me, 'g', linewidth=1.5, label='Medium')
  # ax2.plot(petal_length, pl_bi, 'r', linewidth=1.5, label='Big')
  # ax2.set_title('Petal Length')
  # ax2.legend()

  # ax3.plot(petal_width, pw_sm, 'b', linewidth=1.5, label='Small')
  # ax3.plot(petal_width, pw_me, 'g', linewidth=1.5, label='Medium')
  # ax3.plot(petal_width, pw_bi, 'r', linewidth=1.5, label='Big')
  # ax3.set_title('Petal Width')
  # ax3.legend()

  # for ax in (ax0, ax1, ax2, ax3):
  #     ax.spines['top'].set_visible(False)
  #     ax.spines['right'].set_visible(False)
  #     ax.get_xaxis().tick_bottom()
  #     ax.get_yaxis().tick_left()

  # plt.tight_layout()

  # Aplicando os algoritmos para alcançar as regras finais e as que classificam cada classe
  rules, rules_class1, rules_class2, rules_class3, final_rules, rules_with_degree, rules_with_degree_class1, rules_with_degree_class2, rules_with_degree_class3, final_rules_degree = wang_mendel(x_train, y_train, sepal_length, sl_sm, sl_me, sl_bi, sepal_width, sw_sm, sw_me, sw_bi, petal_length, pl_sm, pl_me, pl_bi, petal_width, pw_sm, pw_me, pw_bi)
  
  # Classificação utilizando as regras sem peso
  classes_mrfc, accuracy_mrfc, classes_mrfg, accuracy_mrfg = classify(x_test, y_test, sepal_length, sl_sm, sl_me, sl_bi, sepal_width, sw_sm, sw_me, sw_bi, petal_length, pl_sm, pl_me, pl_bi, petal_width, pw_sm, pw_me, pw_bi, rules_class1, rules_class2, rules_class3)
  
  # Classificação utilizando as regras com peso
  classes_mrfc_degree, accuracy_mrfc_degree, classes_mrfg_degree, accuracy_mrfg_degree = classify(x_test, y_test, sepal_length, sl_sm, sl_me, sl_bi, sepal_width, sw_sm, sw_me, sw_bi, petal_length, pl_sm, pl_me, pl_bi, petal_width, pw_sm, pw_me, pw_bi, rules_with_degree_class1, rules_with_degree_class2, rules_with_degree_class3)
  
  acc_mrfc.append(accuracy_mrfc)
  acc_mrfg.append(accuracy_mrfg)

  acc_mrfc_degree.append(accuracy_mrfc_degree)
  acc_mrfg_degree.append(accuracy_mrfg_degree)

  print('Fold:', i+1, '\nNúmero de Regras:', len(final_rules))
  for rule in final_rules:
    print(rule)
  print('\n')

  print('mrfc:', classes_mrfc)
  print('mrfg:', classes_mrfg)
  print('\n')

  print('Fold:', i+1, '\nNúmero de Regras:', len(final_rules_degree))
  for rule in final_rules_degree:
    print(rule)
  print('\n')

  print('mrfc_degree:', classes_mrfc_degree)
  print('mrfg_degree:', classes_mrfg_degree)
  print('\n')

print('mrfc:')
acc_mrfc = np.array(acc_mrfc)
print(acc_mrfc.round(2))
print(np.mean(acc_mrfc).round(2))
print(np.std(acc_mrfc).round(2))
print('\n')

print('mrfc_degree:')
acc_mrfc_degree = np.array(acc_mrfc_degree)
print(acc_mrfc_degree.round(2))
print(np.mean(acc_mrfc_degree).round(2))
print(np.std(acc_mrfc_degree).round(2))
print('\n')

print('mrfg:')
acc_mrfg = np.array(acc_mrfg)
print(acc_mrfg.round(2))
print(np.mean(acc_mrfg).round(2))
print(np.std(acc_mrfg).round(2))
print('\n')

print('mrfg_degree:')
acc_mrfg_degree = np.array(acc_mrfg_degree)
print(acc_mrfg_degree.round(2))
print(np.mean(acc_mrfg_degree).round(2))
print(np.std(acc_mrfg_degree).round(2))