# -*- coding: utf-8 -*-
"""epc04.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q0ayuWEbsJtEVLVebmPnDh-H14r3oDqL
"""

# Importando pandas 
import pandas as pd

# Importando numpy
import numpy as np

# Importando `StandardScaler` de `sklearn.preprocessing`
from sklearn.preprocessing import StandardScaler

def generate_empty_matrix(rows, cols):
  matrix = [];
  for i in range(rows):
    line = [];
    for j in range(cols):
      line.append(np.zeros(1)[0]);
    matrix.append(line);
  return matrix;

def generate_weights(rows, cols, inputs):
  matrix = [];
  for i in range(rows):
    neuroniuns = [];
    for j in range(cols):
      weights = [];
      for k in range(inputs):
        weights.append(np.random.rand(1)[0]);
      neuroniuns.append(weights);
    matrix.append(neuroniuns);
  return matrix;

"""Geração da Matriz de Vizinhança"""

def generate_neighborhood(rows, cols):
  neighborhood = [];
  for i in range(rows):
    for j in range(cols):
      neighbors = [];
      if (i > 0) and (i < rows - 1) and (j > 0) and (j < cols - 1):
        neighbors.append({"x": i, "y": j + 1});
        neighbors.append({"x": i + 1, "y": j});
        neighbors.append({"x": i, "y": j - 1});
        neighbors.append({"x": i - 1, "y": j});
      else:
        if (i == 0):
          if (j == 0):
            neighbors.append({"x": i, "y": j + 1});
            neighbors.append({"x": i + 1, "y": j});
          elif (j == (cols - 1)):
            neighbors.append({"x": i, "y": j - 1});
            neighbors.append({"x": i + 1, "y": j});
          elif (j > 0) and (j < cols - 1):
            neighbors.append({"x": i, "y": j - 1});
            neighbors.append({"x": i, "y": j + 1});
            neighbors.append({"x": i + 1, "y": j});
        elif (i == rows - 1):
          if (j == 0):
            neighbors.append({"x": i - 1, "y": j});
            neighbors.append({"x": i, "y": j + 1});
          elif (j == (cols - 1)):
            neighbors.append({"x": i - 1, "y": j});
            neighbors.append({"x": i, "y": j - 1});
          elif (j > 0) and (j < cols - 1):
            neighbors.append({"x": i, "y": j - 1});
            neighbors.append({"x": i, "y": j + 1});
            neighbors.append({"x": i - 1, "y": j});
        if (j == 0):
          if (i > 0) and (i < cols - 1):
            neighbors.append({"x": i - 1, "y": j});
            neighbors.append({"x": i, "y": j + 1});
            neighbors.append({"x": i + 1, "y": j});
        elif (j == cols -1):
          if (i > 0) and (i < cols - 1):
            neighbors.append({"x": i - 1, "y": j});
            neighbors.append({"x": i, "y": j - 1});
            neighbors.append({"x": i + 1, "y": j});
      neighborhood.append(neighbors);
  return neighborhood;

"""Processamento dos dados"""

i = 0;

train_data = pd.read_csv('https://raw.githubusercontent.com/Joacy/pgcc015-inteligencia-computacional/master/epc/epc03/iris-plants/iris-10-'+ str(i + 1) +'tra.txt', sep=',');
test_data = pd.read_csv('https://raw.githubusercontent.com/Joacy/pgcc015-inteligencia-computacional/master/epc/epc03/iris-plants/iris-10-'+ str(i + 1) +'tst.txt', sep=',');

# Separando entradas e saídas para o treinamento
x_train = train_data.iloc[:,0:4];
y_train_text = train_data.iloc[:,4:5];

# Separando entradas e saídas para o teste
x_test = test_data.iloc[:,0:4];
y_test_text = test_data.iloc[:,4:5];

# Normalização dos dados
scaler = StandardScaler().fit(x_train);

# Normalizando dados do treinamento
x_train = scaler.transform(x_train);

# Normalizando dados do teste
x_test = scaler.transform(x_test);

"""Algoritmo SOM"""

def som(map_rows, map_cols, training_data, learning_rate, iterations):
  # Definindo mapa topológico
  map = np.array(generate_empty_matrix(map_rows, map_cols));

  # Montar os conjuntos de vizinhança
  neighborhood = np.array(generate_neighborhood(map.shape[0], map.shape[1])).reshape(map.shape[0], map.shape[1]);

  # Inicializar w aleatoriamente;
  weights = np.array(generate_weights(map.shape[0], map.shape[1], training_data.shape[1]));

  # Inicializar a taxa de aprendizado;
  eta = learning_rate;

  epochs = 0;

  min_x_prev = 999999;
  min_y_prev = 999999;
  min_x_current = 0;
  min_y_current = 0;

  # while (min_x_prev != min_x_current) and (min_y_prev != min_y_current):
  for it in range(iterations):
    min_x_prev = min_x_current;
    min_y_prev = min_y_current;
    
    for i in range(training_data.shape[0]):
      # Cálculo da distância euclidiana
      for j in range(map.shape[0]):
        for k in range(map.shape[1]):
          for l in range(weights.shape[2]):
            map[j][k] += np.power((training_data[i][l] - weights[j][k][l]), 2);
      map = np.sqrt(map);

      # Encontrando neurônio vencedor
      min_x = 0
      min_y = 0
      min = 999999;
      for j in range(map.shape[0]):
        for k in range(map.shape[1]):
          if(min > map[j][k]):
            min_x = j;
            min_y = k;
            min = map[j][k];

      # Atualização dos pesos do neurônio vencedor
      weights[min_x][min_y] = weights[min_x][min_y] + eta * (training_data[i] - weights[min_x][min_y])
      
      # Atualização dos pesos dos vizinhos do neurônio vencedor
      for neighbor in range(len(neighborhood[min_x][min_y])):
        weights[neighborhood[min_x][min_y][neighbor]['x']][neighborhood[min_x][min_y][neighbor]['y']] = weights[neighborhood[min_x][min_y][neighbor]['x']][neighborhood[min_x][min_y][neighbor]['y']] + 0.5 * eta * (training_data[i] - weights[neighborhood[min_x][min_y][neighbor]['x']][neighborhood[min_x][min_y][neighbor]['y']])
    
    min_x_current = min_x
    min_y_current = min_y
    epochs = epochs + 1

  # print(map,'\n');
  # print(epochs,'\n');
  # print(weights,'\n');
  return map, weights, min_x_current, min_y_current, epochs

"""Topologia 1"""

map1, weights1, x_min1, y_min1, epochs1 = som(5, 5, x_train, 0.001, 1000)

from matplotlib import pyplot as plt

plt.imshow(map1, interpolation='nearest')
plt.show()

"""Topologia 2"""

map2, weights2, x_min2, y_min2, epochs2 = som(15, 15, x_train, 0.001, 1000)

plt.imshow(map2, interpolation='nearest')
plt.show()

"""Topologia 3"""

map3, weights3, x_min3, y_min3, epochs3 = som(30, 30, x_train, 0.001, 1000)

plt.imshow(map3, interpolation='nearest')
plt.show()