# -*- coding: utf-8 -*-
"""epc04.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q0ayuWEbsJtEVLVebmPnDh-H14r3oDqL
"""

# Importando pandas 
import pandas as pd

# Importando numpy
import numpy as np

# Importando `StandardScaler` de `sklearn.preprocessing`
from sklearn.preprocessing import StandardScaler

def generate_empty_matrix(rows, cols):
  matrix = [];
  for i in range(rows):
    line = [];
    for j in range(cols):
      line.append(np.zeros(1)[0]);
    matrix.append(line);
  return matrix;

def generate_weights(rows, cols, inputs):
  matrix = [];
  for i in range(rows):
    neuroniuns = [];
    for j in range(cols):
      weights = [];
      for k in range(inputs):
        weights.append(np.random.rand(1)[0]);
      neuroniuns.append(weights);
    matrix.append(neuroniuns);
  return matrix;

def generate_neighborhood(rows, cols):
  neighborhood = [];
  for i in range(rows):
    for j in range(cols):
      neighbors = [];
      if (i > 0) and (i < rows - 1) and (j > 0) and (j < cols - 1):
        neighbors.append({"x": i, "y": j + 1});
        neighbors.append({"x": i + 1, "y": j});
        neighbors.append({"x": i, "y": j - 1});
        neighbors.append({"x": i - 1, "y": j});
      else:
        if (i == 0):
          if (j == 0):
            neighbors.append({"x": i, "y": j + 1});
            neighbors.append({"x": i + 1, "y": j});
          elif (j == (cols - 1)):
            neighbors.append({"x": i, "y": j - 1});
            neighbors.append({"x": i + 1, "y": j});
          elif (j > 0) and (j < cols - 1):
            neighbors.append({"x": i, "y": j - 1});
            neighbors.append({"x": i, "y": j + 1});
            neighbors.append({"x": i + 1, "y": j});
        elif (i == rows - 1):
          if (j == 0):
            neighbors.append({"x": i - 1, "y": j});
            neighbors.append({"x": i, "y": j + 1});
          elif (j == (cols - 1)):
            neighbors.append({"x": i - 1, "y": j});
            neighbors.append({"x": i, "y": j - 1});
          elif (j > 0) and (j < cols - 1):
            neighbors.append({"x": i, "y": j - 1});
            neighbors.append({"x": i, "y": j + 1});
            neighbors.append({"x": i - 1, "y": j});
        if (j == 0):
          if (i > 0) and (i < cols - 1):
            neighbors.append({"x": i - 1, "y": j});
            neighbors.append({"x": i, "y": j + 1});
            neighbors.append({"x": i + 1, "y": j});
        elif (j == cols -1):
          if (i > 0) and (i < cols - 1):
            neighbors.append({"x": i - 1, "y": j});
            neighbors.append({"x": i, "y": j - 1});
            neighbors.append({"x": i + 1, "y": j});
      neighborhood.append(neighbors);
  return neighborhood;

i = 0;

train_data = pd.read_csv('https://raw.githubusercontent.com/Joacy/pgcc015-inteligencia-computacional/master/epc/epc03/iris-plants/iris-10-'+ str(i + 1) +'tra.txt', sep=',');
test_data = pd.read_csv('https://raw.githubusercontent.com/Joacy/pgcc015-inteligencia-computacional/master/epc/epc03/iris-plants/iris-10-'+ str(i + 1) +'tst.txt', sep=',');

# Separando entradas e saídas para o treinamento
x_train = train_data.iloc[:,0:4];
y_train_text = train_data.iloc[:,4:5];

# Separando entradas e saídas para o teste
x_test = test_data.iloc[:,0:4];
y_test_text = test_data.iloc[:,4:5];

# Normalização dos dados
scaler = StandardScaler().fit(x_train);

# Normalizando dados do treinamento
x_train = scaler.transform(x_train);

# Normalizando dados do teste
x_test = scaler.transform(x_test);

# Definindo mapa topológico
map = np.array(generate_empty_matrix(50, 50));

# Montar os conjuntos de vizinhança
neighborhood = np.array(generate_neighborhood(map.shape[0], map.shape[1])).reshape(map.shape[0], map.shape[1]);

# Inicializar w aleatoriamente;
weights = np.array(generate_weights(map.shape[0], map.shape[1], x_train.shape[1]));

# Inicializar a taxa de aprendizado;
eta = 0.001;

# print(map,'\n');
# print(weights,'\n');

epochs = 0;

min_x_prev = 999999;
min_y_prev = 999999;
min_x_current = 0;
min_y_current = 0;

while (min_x_prev != min_x_current) and (min_y_prev != min_y_current):
  min_x_prev = min_x_current;
  min_y_prev = min_y_current;
  
  print(min_x_current, min_y_current) 
  
  for i in range(x_train.shape[0]):
    # Cálculo da distância euclidiana
    for j in range(map.shape[0]):
      for k in range(map.shape[1]):
        for l in range(weights.shape[2]):
          map[j][k] += np.power((x_train[i][l] - weights[j][k][l]), 2);
    map = np.sqrt(map);

    # Encontrando neurônio vencedor
    min_x = 0
    min_y = 0
    min = 999999;
    for j in range(map.shape[0]):
      for k in range(map.shape[1]):
        if(min > map[j][k]):
          min_x = j;
          min_y = k;
          min = map[j][k];

    # Atualização dos pesos do neurônio vencedor
    weights[min_x][min_y] = weights[min_x][min_y] + eta * (x_train[i] - weights[min_x][min_y])
    
    # Atualização dos pesos dos vizinhos do neurônio vencedor
    for neighbor in range(len(neighborhood[min_x][min_y])):
      weights[neighborhood[min_x][min_y][neighbor]['x']][neighborhood[min_x][min_y][neighbor]['y']] = weights[neighborhood[min_x][min_y][neighbor]['x']][neighborhood[min_x][min_y][neighbor]['y']] + 0.5 * eta * (x_train[i] - weights[neighborhood[min_x][min_y][neighbor]['x']][neighborhood[min_x][min_y][neighbor]['y']])
  
  min_x_current = min_x
  min_y_current = min_y
  epochs = epochs + 1

print(map,'\n');
print(epochs,'\n');
# print(weights,'\n');