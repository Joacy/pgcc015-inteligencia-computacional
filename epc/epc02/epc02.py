# -*- coding: utf-8 -*-
"""epc02

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ml9oMnjnSexZFJCdjgtI9kEipvDKvWgU
"""

# Importando pandas 
import pandas as pd

# Importando numpy
import numpy as np

# Importando dados de treinamento e dados de teste
dataset = pd.read_csv('https://raw.githubusercontent.com/Joacy/pgcc015-inteligencia-computacional/master/epc/epc02/dados.txt', sep=' ');
x_test = pd.read_csv('https://raw.githubusercontent.com/Joacy/pgcc015-inteligencia-computacional/master/epc/epc02/teste.txt', sep=' ');

# Separando entradas e saídas para o treinamento
x_train = dataset.iloc[:,0:5];

y_train = dataset.iloc[:,5:6];

# Função sinal

def sinal(u):
  return 1 if u >= 0 else -1

# Cálculo do Erro Quadrático Médio

def calc_eqm(x, d, w):
  eqm = 0;
  cols = w.size;
  rows = int(x.size / cols);
  u = np.zeros((rows));
  
  for i in range(rows):
    for j in range(cols):
      u[i] += x[i][j] * w[j];
      eqm = eqm + np.exp2(d[i] - u[i]);
  return (eqm / (rows * cols));

# Inicialização da taxa de aprendizado e da precisão
eta = 0.0025;

cols = x_train.columns.size;
rows = int(x_train.size / cols);

# Inicialização do vetor de pesos
weights = np.random.rand(cols);

print(weights);

# Treinamento
x = np.array(x_train);

d = np.array(y_train);

u = np.zeros((rows));

eqm_prev = 1e6;
eqm_current = 1;
error = 1e-6;
epochs = 0;

errors = np.zeros(500);

while (abs(eqm_current - eqm_prev) > error):
  u = np.zeros((rows));

  print('|eqm_current - eqm_prev|:', abs(eqm_current - eqm_prev));
  
  eqm_prev = eqm_current;
  
  for i in range(rows):
    for j in range(cols):
      u[i] += x[i][j] * weights[j];
      weights[j] = weights[j] + eta*(d[i] - u[i])*x[i][j];

  print('weights: ', weights);
  eqm_current = calc_eqm(x, d, weights);
  print('eqm: ', eqm_current);

  errors[epochs] = eqm_current;
  epochs = epochs + 1;
  if (epochs > 1000):
    break;

# Teste
rows = int(x_test.size / cols);
x_test = np.array(x_test);
y_test = np.zeros(rows);

for i in range(rows):
  for j in range(cols):
    y_test[i] += x_test[i][j] * weights[j];
  if (sinal(y_test[i]) == 1):
    print('O sinal é para a válvula B');
  else:
    print('O sinal é para a válvula A');

print('épocas:', epochs, '\neqm_current - eqm_prev:', abs(eqm_current - eqm_prev),'\neqm:', eqm_current, '\npesos finais:', weights)

import matplotlib
import matplotlib.pyplot as plt

epochsAxis = np.arange(0.0, epochs);
fig, ax = plt.subplots()
plt.xlim(0, epochs);

ax.plot(epochsAxis, errors[0:epochs])
ax.set(xlabel='Épocas', ylabel='EQM',
       title='EQM ao longo das épocas de treinamento')
ax.grid()