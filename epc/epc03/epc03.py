# -*- coding: utf-8 -*-
"""epc03.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NQQprUpM9AEubecDos7q3ryn6gGo6q99
"""

# Importando pandas 
import pandas as pd

# Importando numpy
import numpy as np

# Importando dados de treinamento e dados de teste para Iris plants data set
for i in range(1):
  train_data = pd.read_csv('https://raw.githubusercontent.com/Joacy/pgcc015-inteligencia-computacional/master/epc/epc03/iris-plants/iris-10-'+ str(i + 1) +'tra.txt', sep=',');
  test_data = pd.read_csv('https://raw.githubusercontent.com/Joacy/pgcc015-inteligencia-computacional/master/epc/epc03/iris-plants/iris-10-'+ str(i + 1) +'tst.txt', sep=',');

  # Separando entradas e saídas para o treinamento
  x_train = train_data.iloc[:,0:4];
  y_train = train_data.iloc[:,4:5];
  
  # Separando entradas e saídas para o teste
  x_test = test_data.iloc[:,0:4];
  y_test = test_data.iloc[:,4:5];

  # Adicionando o bias como uma entrada
  bias_train = (-1 * np.ones(y_train.size)).tolist();
  x_train['bias'] = bias_train;

  bias_test = (-1 * np.ones(y_test.size)).tolist();
  x_test['bias'] = bias_test;

# # Importando dados de treinamento e dados de teste para Glass Identification data set
# for i in range(10):
#   train_data = pd.read_csv('https://raw.githubusercontent.com/Joacy/pgcc015-inteligencia-computacional/master/epc/epc03/glass-identification/glass-10-'+ str(i + 1) +'tra.txt', sep=',');
#   test_data = pd.read_csv('https://raw.githubusercontent.com/Joacy/pgcc015-inteligencia-computacional/master/epc/epc03/glass-identification/glass-10-'+ str(i + 1) +'tst.txt', sep=',');

#   # Separando entradas e saídas para o treinamento
#   x_train = train_data.iloc[:,0:9];
#   y_train = train_data.iloc[:,9:10];

#   # Separando entradas e saídas para o teste
#   x_test = test_data.iloc[:,0:9];
#   y_test = test_data.iloc[:,9:10];

# # Importando dados de treinamento e dados de teste para White Wine Quality data set
# for i in range(10):
#   train_data = pd.read_csv('https://raw.githubusercontent.com/Joacy/pgcc015-inteligencia-computacional/master/epc/epc03/white-wine-quality/winequality-white-10-'+ str(i + 1) +'tra.txt', sep=',');
#   test_data = pd.read_csv('https://raw.githubusercontent.com/Joacy/pgcc015-inteligencia-computacional/master/epc/epc03/white-wine-quality/winequality-white-10-'+ str(i + 1) +'tst.txt', sep=',');
  
#   # Separando entradas e saídas para o treinamento
#   x_train = train_data.iloc[:,0:11];
#   y_train = train_data.iloc[:,11:12];

#   # Separando entradas e saídas para o teste
#   x_test = test_data.iloc[:,0:11];
#   y_test = test_data.iloc[:,11:12];

def sigmoid(u, beta):
  return (1 / (1 + exp(-beta * u)));

def dsigmoid_du(u, beta):
  return (beta * sigmoid(u, beta) * (1 - sigmoid(u, beta)));

def generate_matrix(rows, cols):
  matrix = [];
  for i in range(rows):
    line = [];
    for j in range(cols):
        line.append(np.random.rand(1)[0]);
    matrix.append(line);
  return np.array(matrix);

def generate_empty_matrix(rows, cols):
  matrix = [];
  for i in range(rows):
    line = [];
    for j in range(cols):
        line.append(np.zeros(1)[0]);
    matrix.append(line);
  return np.array(matrix);

def generate_layers(input_size, hidden_size, output_size):
  hidden_layer = generate_matrix(hidden_size, input_size + 1);
  output_layer = generate_matrix(output_size, hidden_size + 1);

  return hidden_layer, output_layer;

hidden_layer, output_layer = generate_layers(x_train.columns.size - 1, x_train.columns.size - 1, y_train.columns.size);

x = np.array(x_train);

# for i in range(int(x_train.size / x_train.columns.size)):
#   u = np.zeros(int(x_train.size / x_train.columns.size));
#   for j in range(hidden_layer.shape[0]):
#     for k in range(hidden_layer.shape[1]):
#       u[i][k] += x[i][j] * hidden_layer[j][k];

hidden_layer

output_layer